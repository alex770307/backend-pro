# Lesson 02

2.  **Средства для работы с многопоточностью в Java и модели многопоточных программ**

1. **Инструменты многопоточности в Java:**
    - В первых версиях Java средства многопоточности ограничивались классом `Thread`, интерфейсом `Runnable`, ключевым словом `synchronized`, и методами `wait()`, `notify()`, `notifyAll()` в классе `Object`.
    - С Java 1.5 появился пакет `java.util.concurrent`, вносящий значительные улучшения и расширения в инструментарий для работы с многопоточностью.
    - В Java 1.8 был добавлен класс `CompletableFuture` для создания асинхронных задач и их комбинирования.

2. **Модели многопоточного программирования:**
    - **Синхронизация и блокировки:** использование `synchronized` и `volatile` для управления доступом к общим ресурсам и обеспечения видимости изменений переменных между потоками.
    - **Транзакционная память:** обеспечивает абстракцию, позволяющую управлять доступом к памяти в многопоточных приложениях, упрощая разработку за счет автоматического контроля за блокировками и изменениями.
    - **Модель акторов:** в этой модели каждый объект (актор) является отдельным потоком и взаимодействует с другими акторами исключительно посредством обмена сообщениями, что уменьшает риск гонок данных и упрощает разработку.

3. **Способы организации многопоточности в программах:**
    - Потоки могут работать независимо друг от друга, не взаимодействуя напрямую.
    - Потоки могут активно взаимодействовать друг с другом, координируя выполнение задач.
    - Потоки могут работать независимо, а затем собирать свои результаты в единый выходной результат.

4. **Потоки в Java:**
    - `Thread` — базовый класс для создания потоков.
    - Создание потоков может происходить через наследование от `Thread` и переопределение метода `run()` или через реализацию интерфейса `Runnable` с последующей передачей его экземпляра в конструктор `Thread`.
    - Предпочтительнее использовать `Runnable` для создания потоков, так как это обеспечивает большую гибкость и позволяет избежать ограничений, связанных с наследованием.

5. **Управление потоками:**
    - Метод `start()` запускает поток, в то время как вызов `run()` просто выполняет код в текущем потоке.
    - Можно устанавливать приоритеты потоков, используя метод `setPriority()`, что влияет на распределение времени процессора между потоками.
    - Потоки-демоны (`daemon threads`) — это служебные потоки, которые не препятствуют завершению работы JVM.
    - Метод `join()` позволяет одному потоку ожидать завершения работы другого потока.
    - Приостановка выполнения потока может быть реализована с помощью `Thread.sleep()`


###  "Остановка и прерывание потоков в Java"

**Засыпание потока (Sleep)**: Потоки могут быть приостановлены на определённое время с использованием метода `Thread.sleep(millis)`, где `millis` — время в миллисекундах.

**Прерывание потока (Interrupt)**: Потоки могут быть прерваны в любой момент их выполнения с помощью метода `interrupt()`. Это важно для безопасного завершения потока.

### Примеры кода

#### Засыпание потока с `Thread.sleep()`
```java
class SleepExample {
    public static void main(String[] args) {
        Runnable sleepTask = () -> {
            try {
                // Поток засыпает на 1 минуту
                Thread.sleep(1000 * 60);
                System.out.println("Проснулся после 1 минуты");
            } catch (InterruptedException e) {
                System.out.println("Сон прерван");
            }
        };

        Thread thread = new Thread(sleepTask);
        thread.start();
    }
}
Copy
Прерывание потока
class InterruptExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    System.out.println("Поток работает");
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                System.out.println("Поток прерван");
                // Восстанавливаем прерывание
                Thread.currentThread().interrupt();
            }
        });

        thread.start();

        // Даем потоку время на выполнение
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Прерываем поток
        thread.interrupt();
    }
}
Copy
Обработка InterruptedException
class InterruptedExceptionHandling {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            while (!Thread.interrupted()) {
                try {
                    // Выполнение каких-то действий
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println("Обработка InterruptedException");
                    // Прерываем поток
                    Thread.currentThread().interrupt();
                }
            }
        });

        thread.start();

        // Прерываем поток после 3 секунд
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
Copy
Прерывание потока во время блокирующей операции
class BlockingOperationInterrupt {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    // Эмуляция блокирующей операции
                    System.out.println("Ожидание ввода...");
                    Thread.sleep(10000);
                }
            } catch (InterruptedException e) {
                System.out.println("Блокирующая операция прервана");
                Thread.currentThread().interrupt();
            }
        });

        thread.start();

        // Прерываем поток через 2 секунды
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
Copy
Метод join() в Java
Введение в join()
Метод join() в Java позволяет одному потоку ожидать завершения другого потока. Это особенно полезно в многопоточных программах, где один поток должен дождаться завершения других потоков перед продолжением выполнения. Этот метод блокирует текущий поток до тех пор, пока целевой поток, на котором был вызван join(), не завершится.

Примеры использования метода join()
Пример 1: Синхронизация счетчика
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

class MyRunnable implements Runnable {
    private final Counter counter;

    public MyRunnable(Counter counter) {
        this.counter = counter;
    }

    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Counter counter = new Counter();
        Thread thread1 = new Thread(new MyRunnable(counter));
        Thread thread2 = new Thread(new MyRunnable(counter));
        thread1.start();
        thread2.start();
        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Count: " + counter.getCount());
    }
}
Copy
В этом примере два потока увеличивают счетчик в общем объекте Counter. Главный поток дожидается их завершения, используя join(), прежде чем выводить итоговое значение счетчика.

Пример 2: Подсчет суммы в потоках
class MyThread extends Thread {
    private int result;

    public void run() {
        result = 0;
        for (int i = 1; i <= 10; i++) {
            result += i;
        }
    }

    public int getResult() {
        return result;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        int result = thread1.getResult() + thread2.getResult();
        System.out.println("Result: " + result);
    }
}
Copy
Здесь два потока вычисляют сумму чисел, а главный поток ожидает их завершения, чтобы суммировать их результаты.

Пример 3: Ожидание выполнения потока
public class App {
    public static void main(String[] args) throws InterruptedException {
        var threadTwo = new Thread(() -> {
            try {
                Thread.sleep(2000);
                int counter = 0;
                for (int i = 0; i < 1000; i++) {
                    counter++;
                }
                var thread = Thread.currentThread().getName();
                System.out.println(thread + " has finished its execution, counter = " + counter);
            } catch (InterruptedException exception) {
                exception.printStackTrace();
            }
        }, "Counter thread");
        threadTwo.start();
        threadTwo.join(); // Ожидание завершения threadTwo
        System.out.println("Main method executing");
    }
}
Copy
В этом случае threadTwo выполняет подсчет, и основной поток (main) ожидает его завершения перед выводом сообщения.

Важные моменты использования потоков
Не запускайте потоки из конструкторов классов, это может привести к неожиданным результатам, особенно при использовании фреймворков, которые создают прокси-объекты (например, Spring).
Потоки и Демоны в Java
В Java существуют пользовательские потоки (создаваемые программистом) и демоны.
Основной поток запускается автоматически и отвечает за выполнение метода main().
Пользовательские потоки можно создавать из основного потока, и они выполняются параллельно ему.
Основной поток обычно завершается последним, выполняя различные операции завершения, такие как закрытие потоков ввода-вывода и соединений с базами данных.
Потоки-демоны
Потоки-демоны работают в фоновом режиме, выполняя вспомогательные операции (например, сборка мусора).
Демоны автоматически завершаются, когда все пользовательские потоки завершили свое выполнение.
Потоки-демоны обычно имеют низкий приоритет и используются для фоновых операций, таких как ввод-вывод или сетевое взаимодействие.
Создание и использование потоков-демонов
Получение имени текущего потока
public class App {
    public static void main(String[] args) {
        var threadName = Thread.currentThread().getName();
        System.out.println("Thread that is executing: " + threadName);
    }
}
Copy
Этот код иллюстрирует использование метода Thread.getName(), который возвращает имя текущего выполняющегося потока.
Пример с потоком-демоном
public class App {
    public static void main(String[] args) {
        var worker = new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            var threadName = Thread.currentThread().getName();
            System.out.println("Thread is finishing its execution with name: " + threadName);
        }, "Worker");

        var daemon = new Thread(() -> {
            while (true) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                var threadName = Thread.currentThread().getName();
                System.out.println("Thread is executing with name: " + threadName);
            }
        }, "Daemon");

        daemon.setDaemon(true);
        worker.start();
        daemon.start();

        var threadName = Thread.currentThread().getName();
        System.out.println("Thread is executing with name: " + threadName);
    }
}
Copy
В этом примере worker выполняет задачу и завершается, в то время как daemon продолжает выполняться в бесконечном цикле.
Установка потока как демона (daemon.setDaemon(true)) означает, что он будет автоматически завершен, когда все пользовательские потоки завершат свою работу.
setDaemon(true) должен вызываться до запуска потока; иначе будет выброшено IllegalThreadStateException.
Общие принципы работы с потоками в Java
Важно понимать разницу между пользовательскими потоками и демонами, особенно когда это влияет на процесс завершения приложения.
Потоки-демоны полезны для выполнения фоновых задач, но не следует использовать их для критически важных операций, поскольку они могут быть неожиданно завершены.
Управление жизненным циклом потоков важно для корректной работы многопоточных приложений.
Синхронизация потоков в Java
Проблемы многопоточности
Последовательность выполнения действий в разных потоках может привести к неожиданным результатам.
Параллельный доступ к общим ресурсам без должной синхронизации может вызвать гонки данных (race conditions) и привести к неправильному поведению программы.
Взаимные блокировки и неравномерное распределение ресурсов между потоками могут снижать производительность и приводить к ошибкам.
Синхронизация потоков
Синхронизация в Java предоставляет механизмы для упорядочивания доступа потоков к общим ресурсам.
Ключевое слово synchronized используется для определения блоков кода или методов, которые должны быть защищены от одновременного доступа нескольких потоков.
Методы синхронизации
Модификатор synchronized для методов:

public synchronized void method() {
    // Тело метода
}
Copy
Когда поток вызывает синхронизированный метод, он захватывает монитор объекта (или класса, если метод статический).

Синхронизированный блок внутри методов:

public void method() {
    synchronized(this) {
        // Тело синхронизированного блока
    }
}
Copy
Синхронизированный блок позволяет уточнить объект, монитор которого будет использован для блокировки.

Примеры синхронизации
Проблема синхронизации счётчика
Рассмотрим проблему, когда несколько потоков инкрементируют одну и ту же переменную. Без синхронизации конечное значение переменной будет непредсказуемым из-за race conditions.
Синхронизация с использованием synchronized
Добавление synchronized к методу increaseCounter гарантирует, что каждый поток будет увеличивать счетчик последовательно, обеспечивая правильный итоговый результат.
Потокобезопасные классы в Java
Java предлагает потокобезопасные версии стандартных коллекций (например, Vector, ConcurrentHashMap), которые обеспечивают автоматическую синхронизацию при доступе к элементам коллекции из разных потоков, тем самым упрощая разработку многопоточных приложений.
Понятие монитора в контексте Java
Каждый объект в Java имеет связанный с ним монитор, который помогает управлять доступом к синхронизированным блокам кода.
Монитор объекта содержит внутренние механизмы для управления блокировкой, ожиданием и уведомлением потоков.
Внутреннее устройство монитора
Мониторы в Java содержат внутренние механизмы для управления доступом потоков, включая механизмы ожидания и уведомления (wait(), notify(), notifyAll()).
Пример использования мониторов и синхронизированных блоков
Рассмотрим более сложный пример, демонстрирующий использование синхронизированных блоков с разными объектами-мониторами для разных частей кода:

class Example {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            // Код, требующий синхронизации с использованием lock1
        }
    }

    public void method2() {
        synchronized(lock2) {
            // Код, требующий синхронизации с использованием lock2
        }
    }
}
Copy
В этом примере method1 и method2 могут выполняться параллельно, так как они синхронизированы на разных объектах.

Потокобезопасность и атомарные операции
Некоторые операции в Java являются атомарными (например, чтение и запись примитивных типов, за исключением long и double), что означает, что они выполняются в одном шаге без возможности прерывания.
Использование ключевого слова volatile гарантирует, что чтение и запись переменной происходит напрямую в память, обеспечивая таким образом видимость изменений между разными потоками.
Избегание блокировок (Deadlocks)
Важно проектировать многопоточные приложения таким образом, чтобы избежать взаимных блокировок, когда два или более потоков ждут ресурсы, захваченные друг другом, создавая тем самым состояние вечного ожидания.
Рекомендации по синхронизации
Используйте синхронизацию экономно, чтобы не снизить производительность приложения.
При проектировании многопоточных приложений всегда учитывайте возможность возникновения состояний гонки, взаимных блокировок и других проблем многопоточности.
Изучайте и используйте высокоуровневые абстракции и утилиты для многопоточности из пакета java.util.concurrent, которые могут помочь упростить разработку многопоточных приложений и сделать ее более надежной.
Многопоточность в Java с использованием java.util.concurrent
С появлением Java 1.5 был введён пакет java.util.concurrent, который представляет собой мощный инструментарий для разработки многопоточных приложений. Этот пакет содержит набор классов для реализации многопоточности, включая синхронизаторы и параллельные коллекции, обеспечивающие более высокий уровень абстракции по сравнению с традиционными методами синхронизации.

